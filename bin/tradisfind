#!/usr/bin/env perl

=head1 NAME

tradisfind

=head1 SYNOPSIS

tradisfind -t study -id "My study name"
tradisfind -t lane -id 1234_5#6

=head1 DESCRIPTION

Given a lane id, a study id or a study name, it will return the paths to the rna seq data

=head1 CONTACT

path-help@sanger.ac.uk

=head1 METHODS

=cut

use strict;
use warnings;
no warnings 'uninitialized';

use Cwd;
use lib "/software/pathogen/internal/pathdev/vr-codebase/modules"
  ;    #Change accordingly once we have a stable checkout
use lib "/software/pathogen/internal/prod/lib";
use lib "../";

use Getopt::Long;
use File::Basename;

use Path::Find;
use Path::Find::Lanes;
use Path::Find::Filter;
use Path::Find::Linker;
use Path::Find::Log;
eval {
    Path::Find::Log->new(
        logfile => '/nfs/pathnfs05/log/pathfindlog/tradisfind.log',
        args    => \@ARGV
    )->commandline();
};

my (
    $type,  $id,        $symlink, $archive, $help, $verbose,
    $stats, $file_type, $ref,     $date,    $mapper
);

GetOptions(
    't|type=s'      => \$type,
    'i|id=s'        => \$id,
    'h|help'        => \$help,
    'f|filetype=s'  => \$filetype,
    'l|symlink:s'   => \$symlink,
    'a|archive:s'   => \$archive,
    's|stats:s'     => \$stats,
    'v|verbose'     => \$verbose,
    'r|reference=s' => \$ref,
    'd|date=s'      => \$date,
    'm|mapper=s'    => \$mapper,
);

(
    $type && $id && $id ne '' && ( $type eq 'study'
        || $type eq 'lane'
        || $type eq 'sample'
        || $type eq 'file'
        || $type eq 'species'
        || $type eq 'database' )
) or die <<USAGE;

Usage: $0
  -t|type      <study|lane|file|sample|species>
  -i|id        <study id|study name|lane name>
  -l|symlink   <create a symlink to the data>
  -a|arvhive   <archive the data>
  -f|filetype  <coverage|intergenic|bam|spreadsheet>
  -s|stats     <output stats to file>
  -v|verbose   <extended details>
  -r|reference <select only results mapped to given reference>
  -d|date      <select only results produced after given date>
  -m|mapper    <select only results produced by given mapper>
  -h|help      <print this message>

Given a study or lane this will give you the location of the Tradis results. By default it provides the directory, but by specifiying a 'file_type' 
you can narrow it down to particular 
files within the result set. For a single Tradis experiment you will have:

a BAM file with reads corrected according to the protocol,
a spreadsheet with statistics about insertions on each gene,
insertion site plots for each sequence which can be opened in Artemis,
tab files for each sequence with intergenic regions marked up, which can be opened in Artemis.

USAGE

die "The archive and symlink options cannot be used together\n"
  if ( defined $archive && defined $symlink );



# set file type extension regular expressions
my %type_extensions = (
    coverage    => 'insert_site_plot\.gz$',
    intergenic  => 'tab\.gz$',
    bam         => 'corrected\.bam$',
    spreadsheet => 'insertion\.csv$',
);

my $lane_filter;

# Get databases and loop through them
my @pathogen_databases = Path::Find->pathogen_databases;
for my $database (@pathogen_databases) {

    # Connect to database and get info
    my ( $pathtrack, $dbh, $root ) = Path::Find->get_db_info($database);

    my $find_lanes = Path::Find::Lanes->new(
        search_type    => $type,
        search_id      => $id,
        pathtrack      => $pathtrack,
        dbh            => $dbh,
        processed_flag => 512
    );
    my @lanes = @{ $find_lanes->lanes };

    # filter lanes
    my @directory_or_file_paths;
    my @extended_analysis_details;
    for my $lane_obj (@lanes) {
        my $path =
          $pathtrack->hierarchy_path_of_lane( $lane_obj, $hierarchy_template );
        my $full_path = "$root/$path";
        next unless ( -d $full_path );

        if ( defined($file_type) && defined $file_types{$file_type} ) {
            push( @directory_or_file_paths,
                find_files_by_type( $file_types{$file_type}, $full_path ) );
        }
        else {
            push( @directory_or_file_paths, $full_path );
        }

        if ($extended_details) {
            my @bam_files = find_files_by_type( $file_types{bam}, $full_path );
            for my $bam_file (@bam_files) {
                if ( -l $bam_file ) {
                    next;
                }
                my $mapstats_id = find_mapstats_id($bam_file);
                next unless ( defined($mapstats_id) );

                my $reference_location = get_reference_location($bam_file);

                my @coverage_plots = grep { /$mapstats_id/ }
                  find_files_by_type( $file_types{coverage}, $full_path );
                for my $coverage_plot (@coverage_plots) {
                    push(
                        @extended_analysis_details,
                        join( "\t",
                            ( $coverage_plot, $reference_location, $bam_file ) )
                    );
                }

            }

        }
    }

    # symlink
    if ( defined $symlink ) {
        for my $filtered_path (@directory_or_file_paths) {
            `ln -s $filtered_path `;
            if ( $filtered_path =~ /.bam$/ ) {
                `ln -s $filtered_path.bai `;
            }

        }
    }

    if ($extended_details) {
        for my $analysis_details (@extended_analysis_details) {
            print $analysis_details . "\n";
            $found = 1;
        }
    }
    else {
        # print out the paths
        for my $filtered_path (@directory_or_file_paths) {
            print $filtered_path. "\n";
            $found = 1;
        }
    }

    $dbh->disconnect();
    if ( $found
      )    #no need to look in the next database if relevant data has been found
    {
        exit;
    }
}

unless ($found) {

    print "Could not find lanes or files for input data \n";

}

sub find_mapstats_id {
    my ($bamfile_path) = @_;
    my ( $filename, $directories, $suffix ) = fileparse($bamfile_path);
    $filename =~ s!\.corrected\.bam$!!;
    return $filename;
}

sub find_files_by_type {
    my ( $type, $base_path ) = @_;

    opendir( DIR, $base_path );
    my @filenames = grep { /$type/i } readdir(DIR);
    closedir(DIR);
    for ( my $i = 0 ; $i < @filenames ; $i++ ) {
        $filenames[$i] = $base_path . '/' . $filenames[$i];
    }

    return @filenames;
}

sub get_reference_location {
    my $bam_file = shift;
    open( IN, "-|", 'samtools view -H ' . $bam_file . ' | grep "^@SQ" ' )
      or die "couldnt open bamfile";
    my $seq_line = <IN>;
    return "" unless defined($seq_line);
    if ( $seq_line =~ /UR:file:(.+)fa/ ) {
        return $1 . "gff";
    }
    return "";

}

