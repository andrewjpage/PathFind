#!/usr/bin/env perl

=head1 NAME

tradisfind

=head1 SYNOPSIS

tradisfind -t study -id "My study name"
tradisfind -t lane -id 1234_5#6

=head1 DESCRIPTION

Given a lane id, a study id or a study name, it will return the paths to the rna seq data

=head1 CONTACT

path-help@sanger.ac.uk

=head1 METHODS

=cut

use strict;
use warnings;
no warnings 'uninitialized';

use Cwd;
use lib "/software/pathogen/internal/pathdev/vr-codebase/modules"
  ;    #Change accordingly once we have a stable checkout
use lib "/software/pathogen/internal/prod/lib";
use lib "../lib";

use Getopt::Long;
use File::Basename;

use Path::Find;
use Path::Find::Lanes;
use Path::Find::Filter;
use Path::Find::Linker;
use Path::Find::Verbose;
use Path::Find::Log;
eval {
    Path::Find::Log->new(
        logfile => '/nfs/pathnfs05/log/pathfindlog/tradisfind.log',
        args    => \@ARGV
    )->commandline();
};

my (
    $type,  $id,       $symlink, $archive, $help, $verbose,
    $stats, $filetype, $ref,     $date,    $mapper
);

GetOptions(
    't|type=s'      => \$type,
    'i|id=s'        => \$id,
    'h|help'        => \$help,
    'f|filetype=s'  => \$filetype,
    'l|symlink:s'   => \$symlink,
    'a|archive:s'   => \$archive,
    's|stats:s'     => \$stats,
    'v|verbose'     => \$verbose,
    'r|reference=s' => \$ref,
    'd|date=s'      => \$date,
    'm|mapper=s'    => \$mapper,
);

(
         $type
      && $id
      && $id ne ''
      && ( $type eq 'study'
        || $type eq 'lane'
        || $type eq 'sample'
        || $type eq 'file'
        || $type eq 'species'
        || $type eq 'database' )
      && (
        !$filetype
        || (
            $filetype
            && (   $filetype eq 'bam'
                || $filetype eq 'spreadsheet'
                || $filetype eq 'intergenic'
                || $filetype eq 'coverage' )
        )
      )
) or die <<USAGE;

Usage: $0
  -t|type      <study|lane|file|sample|species>
  -i|id        <study id|study name|lane name>
  -l|symlink   <create a symlink to the data>
  -a|arvhive   <archive the data>
  -f|filetype  <coverage|intergenic|bam|spreadsheet>
  -s|stats     <output stats to file>
  -v|verbose   <extended details>
  -r|reference <select only results mapped to given reference>
  -d|date      <select only results produced after given date>
  -m|mapper    <select only results produced by given mapper>
  -h|help      <print this message>

Given a study or lane this will give you the location of the Tradis results. By default it provides the directory, but by specifiying a 'file_type' 
you can narrow it down to particular 
files within the result set. For a single Tradis experiment you will have:

a BAM file with reads corrected according to the protocol,
a spreadsheet with statistics about insertions on each gene,
insertion site plots for each sequence which can be opened in Artemis,
tab files for each sequence with intergenic regions marked up, which can be opened in Artemis.

USAGE

die "The archive and symlink options cannot be used together\n"
  if ( defined $archive && defined $symlink );

# set file type extension regular expressions
my %type_extensions = (
    coverage    => 'insert_site_plot\.gz$',
    intergenic  => 'tab\.gz$',
    bam         => 'corrected\.bam$',
    spreadsheet => 'insertion\.csv$',
);

my ($lane_filter, $vb);
my $found = 0;

# Get databases and loop through them
my @pathogen_databases = Path::Find->pathogen_databases;
for my $database (@pathogen_databases) {

    # Connect to database and get info
    my ( $pathtrack, $dbh, $root ) = Path::Find->get_db_info($database);

    my $find_lanes = Path::Find::Lanes->new(
        search_type    => $type,
        search_id      => $id,
        pathtrack      => $pathtrack,
        dbh            => $dbh,
        processed_flag => 512
    );
    my @lanes = @{ $find_lanes->lanes };

    unless (@lanes) {
        $dbh->disconnect();
        next;
    }

    # filter lanes
    $filetype = "bam" if ( $verbose || $date || $ref || $mapper );
    $lane_filter = Path::Find::Filter->new(
        lanes           => \@lanes,
        filetype        => $filetype,
        root            => $root,
        pathtrack       => $pathtrack,
        type_extensions => \%type_extensions
    );
    my @matching_lanes = $lane_filter->filter;

    if ( $verbose || $ref || $mapper || $date ) {

        # retrieve and filter verbose info: ref, mapper, date
        #my @verbose = @matching_lanes;
        $vb = Path::Find::Verbose->new(
            lanes     => \@matching_lanes,
            reference => $ref,
            mapper    => $mapper,
            date      => $date
        );

        @matching_lanes = @{ $vb->filter_on_reference } if ($ref);
        @matching_lanes = @{ $vb->filter_on_mapper }    if ($mapper);
        @matching_lanes = @{ $vb->filter_on_date }      if ($date);
    }

	# Set up to symlink/archive. Check whether default filetype should be used
    my $use_default = 0;
    $use_default = 1 if ( !defined $filetype );
    if ( $lane_filter->found && ( $symlink || $archive ) ) {
        my $name;
        if ( defined $symlink ) {
            $name = $symlink;
        }
        elsif ( defined $archive ) {
            $name = $archive;
        }
        $name = $id if ( $name eq '' );

        my $linker = Path::Find::Linker->new(
            lanes            => \@matching_lanes,
            name             => $name,
            use_default_type => $use_default
        );

        $linker->sym_links if ($symlink);
        $linker->archive   if ($archive);
    }

    if ($verbose) {
        my @verbose = @{ $vb->get_verbose_info };
        next unless (@verbose);
        $found = 1;
        foreach my $v_lane (@verbose) {
            print "$v_lane\n";
        }
    }
    else {
        if (@matching_lanes) {
            $found = 1;
            foreach my $lane (@matching_lanes) {
                print "$lane\n";
            }
        }
    }

    $dbh->disconnect();

    #no need to look in the next database if relevant data has been found
    exit if ($found);
}

unless ($found) {

    print "Could not find lanes or files for input data \n";

}

