#!/usr/bin/env perl

=head1 NAME

mapfind

=head1 SYNOPSIS

mapfind -t study -id "My study name"
mapfind -t lane -id 1234_5#6

=head1 DESCRIPTION

Given a lane id, a study id or a study name, it will return the paths to the mapped bam files.

=head1 CONTACT

path-help@sanger.ac.uk

=head1 METHODS

=cut

use strict;
use warnings;
no warnings 'uninitialized';

use Data::Dumper;
use Cwd;
use lib "/software/pathogen/internal/pathdev/vr-codebase/modules";    #Change accordingly once we have a stable checkout
use lib "/software/pathogen/internal/prod/lib";
use lib "../lib";
use Getopt::Long;

use Path::Find;
use Path::Find::Lanes;
use Path::Find::Filter;
use Path::Find::Linker;
use Path::Find::Verbose;
use Path::Find::Log;
eval{ Path::Find::Log->new(logfile => '/nfs/pathnfs05/log/pathfindlog/mapfind.log', args => \@ARGV)->commandline(); };

my (
    $type,  $id,        $symlink, $archive, $help, $verbose,
    $stats, $filetype, $ref,     $date,    $mapper
);

GetOptions(
    't|type=s'      => \$type,
    'i|id=s'        => \$id,
    'h|help'        => \$help,
    'f|filetype=s'  => \$filetype,
    'l|symlink:s'   => \$symlink,
    'a|archive:s'   => \$archive,
    's|stats:s'     => \$stats,
    'v|verbose'     => \$verbose,
    'r|reference=s' => \$ref,
    'd|date=s'      => \$date,
    'm|mapper=s'    => \$mapper,
);

(
    $type && $id && $id ne '' && ( $type eq 'study'
        || $type eq 'lane'
        || $type eq 'sample'
        || $type eq 'file'
        || $type eq 'species'
        || $type eq 'database' )
) or die <<USAGE;

Usage: $0
     -t|type  		<study|lane|file|sample|species>
     -i|id 		<study id|study name|lane name|file of lane names>
	 -f|filetype	<bam>
     -l|symlink 		<create a symlink to the data>
	 -a|arvhive		<archive the data>
     -v|verbose         <display reference and mapper>
     -s|stats           <output file for summary of mapping results in CSV format>
	 -r|reference	<filter results based on reference>
	 -m|mapper	<filter results based on mapper>
	 -d|date	<show only results produced after a given date>
     -h|help  		<print this message>

***********
Given a study, lane or a file containing a list of lanes, this script will output the path (on pathogen disk) to the mapped bam files with the specified study or lane. 
Using the option -qc (passed|failed|pending) will limit the results to data of the specified qc status.
Using the option -reference will limit the results to a lanes mapped against a specific reference (eg 'H1N1','3D7').
Using the option -symlink will create a symlink to the queried data in the current directory, alternativley an output directory can be specified in which the symlinks will be created.
Using the option -rename will rename the symlink to include the lane. Alternatively, the symlink can be renamed to include the sample, reference, mapper or lane by supplying any combination of these terms to the -rename option (e.g. -rename sample.mapper or -rename reference.lane).
USAGE

die "The archive and symlink options cannot be used together\n"
  if ( defined $archive && defined $symlink );

# set file type extension regular expressions
my %type_extensions = (
    bam         => 'markdup\.bam$',
);

my $lane_filter;
my $found = 0;

# Get databases and loop through them
my @pathogen_databases = Path::Find->pathogen_databases;
for my $database (@pathogen_databases) {

    # Connect to database and get info
    my ( $pathtrack, $dbh, $root ) = Path::Find->get_db_info($database);

    my $find_lanes = Path::Find::Lanes->new(
        search_type    => $type,
        search_id      => $id,
        pathtrack      => $pathtrack,
        dbh            => $dbh,
        processed_flag => 512
    );
    my @lanes = @{ $find_lanes->lanes };

	

	unless (@lanes) {
        $dbh->disconnect();
        next;
    }

    # filter lanes
	$lane_filter = Path::Find::Filter->new(
        lanes           => \@lanes,
        filetype        => $filetype,
        root            => $root,
        pathtrack       => $pathtrack,
        type_extensions => \%type_extensions,
    );
    my @matching_lanes = $lane_filter->filter;

    # Set up to symlink/archive. Check whether default filetype should be used
    my $use_default = 0;
    $use_default = 1 if ( !defined $filetype );
    if ( $lane_filter->found && ( $symlink || $archive ) ) {
        my $name;
        if ( defined $symlink ) {
            $name = $symlink;
        }
        elsif ( defined $archive ) {
            $name = $archive;
        }
        $name = $id if ( $name eq '' );

        my $linker = Path::Find::Linker->new(
            lanes            => \@matching_lanes,
            name             => $name,
            use_default_type => $use_default
        );

        $linker->sym_links if ($symlink);
        $linker->archive   if ($archive);
    }

	if ($verbose || $ref || $mapper || $date) {
		# retrieve and filter verbose info: ref, mapper, date
		my @verbose = \@matching_lanes;
        my $vb = Path::Find::Verbose->new(
			lanes => \@verbose,
			reference => $ref,
			mapper => $mapper,
			date => $date
		);
		
		@verbose = @{ $vb->filter_on_reference } if($ref);
		@verbose = @{ $vb->filter_on_mapper } if($mapper);
		@verbose = @{ $vb->filter_on_date } if($date);
		@verbose = @{ $vb->get_verbose_info } if($verbose);
		
		if(@verbose){
			$found = 1;
			foreach my $v_lane (@verbose){
				print "$v_lane\n";
			}
		}
		
    }
    else {
        if(@matching_lanes){
			$found = 1;
			foreach my $lane (@matching_lanes){
				print "$lane\n";
			}
		}
    }

	$lane_filter->lane_objects(\@matching_lanes);

	my $csv_file;
    # Output CSV file
    if ( $csv_file && $found ) {
		# set default stats file name
		my $csv_file = $stats || $id;
		$csv_file =~ s/\s+/_/g;
		$csv_file .= ".csv";
		
		# output lanes to file
		Path::Find::Stats->new(
			lanes => \@matching_lanes,
			output => $csv_file,
			vrtrack => $pathtrack
			)->output_csv_file;
    }

    $dbh->disconnect();
    if ($found)    #no need to look in the next database if relevant data has been found
    {
        exit;
    }
}

unless ($found) {

    print "Could not find lanes or files for input data \n";

}


