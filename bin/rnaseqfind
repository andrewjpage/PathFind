#!/usr/bin/env perl

=head1 NAME

rnaseqfind

=head1 SYNOPSIS

rnaseqfind -t study -id "My study name"
rnaseqfind -t lane -id 1234_5#6

=head1 DESCRIPTION

Given a lane id, a study id or a study name, it will return the paths to the rna seq data

=head1 CONTACT

path-help@sanger.ac.uk

=head1 METHODS

=cut

use strict;
use warnings;
no warnings 'uninitialized';

use Cwd;
use lib "/software/pathogen/internal/pathdev/vr-codebase/modules"; #Change accordingly once we have a stable checkout
use lib "/software/pathogen/internal/prod/lib";
use lib "../lib";
use Getopt::Long;

use Path::Find;
use Path::Find::Lanes;
use Path::Find::Filter;
use Path::Find::Linker;
use Path::Find::Stats;
use Path::Find::Log;
eval{ Path::Find::Log->new(logfile => '/nfs/pathnfs05/log/pathfindlog/rnaseqfind.log', args => \@ARGV)->commandline(); };

my (
    $type,  $id,       $symlink, $archive, $help,   $verbose,
    $stats, $filetype, $ref,     $date,    $mapper, $qc
);

GetOptions(
    't|type=s'      => \$type,
    'i|id=s'        => \$id,
    'h|help'        => \$help,
    'f|filetype=s'  => \$filetype,
    'l|symlink:s'   => \$symlink,
    'a|archive:s'   => \$archive,
    's|stats:s'     => \$stats,
    'v|verbose'     => \$verbose,
    'r|reference=s' => \$ref,
    'd|date=s'      => \$date,
    'm|mapper=s'    => \$mapper,
    'q|qc=s'        => \$qc
);

(
    $type && $id && $id ne '' && ( $type eq 'study'
        || $type eq 'lane'
        || $type eq 'sample'
        || $type eq 'file'
        || $type eq 'species'
        || $type eq 'database' )
) or die <<USAGE;

Usage: $0
     -t|type      <study|lane|file|sample|species>
     -i|id        <study id|study name|lane name|file of lane names>
     -f|filetype  <bam>
     -q|qc        <pass|failed|pending>
     -l|symlink   <create a symlink to the data>
     -a|arvhive   <archive the data>
     -v|verbose   <display reference, mapper and date>
     -s|stats     <output file for summary of mapping results in CSV format>
     -r|reference <filter results based on reference>
     -m|mapper    <filter results based on mapper>
     -d|date      <show only results produced after a given date>
     -h|help      <print this message>

***********
Given a study or lane this will give you the location of the RNA Seq results. By default it provides the directory, but by specifiying a 'file_type' you can narrow it down to particular 
files within the result set. For a single RNA seq experiment you will have:

a BAM file with reads corrected according to the protocol,
a spreadsheet with RPKM and read counts for each CDS/polypeptide,
coverage plots for each sequence which can be opened in Artemis,
optional tab files for each sequence with intergenic regions marked up, which can be opened in Artemis.

Using the option -l|symlink will create a symlink to the queried data in the given directory (this will be created if it does not already exist). 
Similarly, using the -a|archive option will create an archive of the results with the given filename. 
The -s|stats option will produce a CSV file summarising the mapping statistics for the resulting lanes.
In symlink, archive and stats cases, if no name is provided, a default based on the given ID will be used.

Using the option -r|reference will limit the results to a lanes mapped against a specific reference (eg 'H1N1','3D7').
The -m|mapper option will limit results to lanes mapped using the specified mapper (eg smalt, bowtie2 )
The -d|date option will limit results to lanes processed after a given date. The date format should be dd-mm-yyyy (eg 01-01-2010)

USAGE

die "The archive and symlink options cannot be used together\n"
  if ( defined $archive && defined $symlink );


my %type_extensions = (
  coverage    => '*coverageplot.gz',
  intergenic  => '*tab.gz',
  bam         => '*corrected.bam',
  spreadsheet => '*expression.csv',
  );

my $lane_filter;
my $found = 0;

# Get databases and loop through them
my @pathogen_databases = Path::Find->pathogen_databases;
for my $database (@pathogen_databases) {

    # Connect to database and get info
    my ( $pathtrack, $dbh, $root ) = Path::Find->get_db_info($database);

    my $find_lanes = Path::Find::Lanes->new(
        search_type    => $type,
        search_id      => $id,
        pathtrack      => $pathtrack,
        dbh            => $dbh,
        processed_flag => 512
    );
    my @lanes = @{ $find_lanes->lanes };

    unless (@lanes) {
        $dbh->disconnect();
        next;
    }

   	# filter lanes
    $lane_filter = Path::Find::Filter->new(
        lanes           => \@lanes,
        filetype        => $filetype,
        root            => $root,
        pathtrack       => $pathtrack,
        type_extensions => \%type_extensions,
        qc              => $qc,
        reference       => $ref,
        mapper          => $mapper,
        date            => $date,
        verbose         => $verbose
    );
    my @matching_lanes = $lane_filter->filter;

	unless (@matching_lanes) {
        $dbh->disconnect();
        next;
    }

    # Set up to symlink/archive. Check whether default filetype should be used
    my $use_default = 0;
    $use_default = 1 if ( !defined $filetype );
    if ( $lane_filter->found && ( defined $symlink || defined $archive ) ) {
        my $name;
        if ( defined $symlink ) {
            $name = $symlink;
        }
        elsif ( defined $archive ) {
            $name = $archive;
        }
        $name = "rnaseqfind_$id" if ( $name eq '' );

        my $linker = Path::Find::Linker->new(
            lanes            => \@matching_lanes,
            name             => $name,
            use_default_type => $use_default
        );

        $linker->sym_links if (defined $symlink);
        $linker->archive   if (defined $archive);
    }

    if (@matching_lanes) {
		$found = 1;
        if ($verbose) {
            foreach my $ml (sort { $a->{path} cmp $b->{path} } @matching_lanes) {
				my $l = $ml->{path};
				my $r = $ml->{ref};
				my $m = $ml->{mapper};
				my $d = $ml->{date};
                print "$l\t$r\t$m\t$d\n";
            }
        }
        else {
            foreach my $ml (sort { $a->{path} cmp $b->{path} } @matching_lanes) {
				my $l = $ml->{path};
                print "$l\n";
            }
        }
    }


   $dbh->disconnect();
   if( $found ) #no need to look in the next database if relevant data has been found
   {
      exit;
   }
}

unless ($found) {

    print "Could not find lanes or files for input data \n";

}