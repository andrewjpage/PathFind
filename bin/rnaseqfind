#!/usr/bin/env perl

=head1 NAME

rnaseqfind

=head1 SYNOPSIS

rnaseqfind -t study -id "My study name"
rnaseqfind -t lane -id 1234_5#6

=head1 DESCRIPTION

Given a lane id, a study id or a study name, it will return the paths to the rna seq data

=head1 CONTACT

path-help@sanger.ac.uk

=head1 METHODS

=cut

use strict;
use warnings;
no warnings 'uninitialized';

use Cwd;
use lib "/software/pathogen/internal/pathdev/vr-codebase/modules"; #Change accordingly once we have a stable checkout
use lib "/software/pathogen/internal/prod/lib";
use Getopt::Long;
use Pathfind;
use FindLanes;
use PathfindLog;
eval{ PathfindLog->new(logfile => '/nfs/pathnfs05/log/pathfindlog/rnaseqfind.log', args => \@ARGV)->commandline(); };

my ($type, $id, $symlink, $help, $file_type);

GetOptions(
   't|type=s'   	=> \$type,
   'i|id=s'		=> \$id,
   's|symlink' 		=> \$symlink,
   'f|file_type=s' => \$file_type,
   'h|help'		=> \$help,
    );

($type && $id && $id ne '' && ($type eq 'study' || $type eq 'lane' || $type eq 'file' || $type eq 'sample' || $type eq 'species'  || $type eq 'database') ) or die <<USAGE;

Usage: $0
  -t|type      <study|lane|file|sample|species>
  -i|id        <study id|study name|lane name|file of lane names>
  -s|symlink   <create a symlink to the data>
  -f|file_type <coverage|intergenic|bam|spreadsheet>
  -h|help      <print this message>

Given a study or lane this will give you the location of the RNA Seq results. By default it provides the directory, but by specifiying a 'file_type' you can narrow it down to particular 
files within the result set. For a single RNA seq experiment you will have:

a BAM file with reads corrected according to the protocol,
a spreadsheet with RPKM and read counts for each CDS/polypeptide,
coverage plots for each sequence which can be opened in Artemis,
optional tab files for each sequence with intergenic regions marked up, which can be opened in Artemis.

USAGE

# Get databases
my @pathogen_databases = Pathfind->pathogen_databases;
my $hierarchy_template = Pathfind->hierarchy_template;

                           
my %file_types = (
  coverage    => 'coverageplot.gz$',
  intergenic  => 'tab.gz$',
  bam         => 'corrected.bam$',
  spreadsheet => 'expression.csv$',
  );

my $pathtrack;
my $found = 0; #assume nothing found
my $min = 0;
my $max = 1;
my $destination;


for my $database (@pathogen_databases){

    # Connect to database
    $pathtrack = Pathfind->instantiate_vrtrack($database) or die "Failed to create VRTrack object for '$database'\n";
    my $dbh    = Pathfind->instantiate_dbi($database)     or die "Failed to create DBI object for '$database'\n";
    my $root   = Pathfind->hierarchy_root_dir($database)  or die "Failed to find root directory for '$database'\n";

    my $find_lanes = FindLanes->new(
        search_type => $type,
        search_id   => $id,
        pathtrack   => $pathtrack,
        dbh         => $dbh,
        processed_flag => 512
    );
    my @lanes = @{ $find_lanes->lanes };

   # check directories exist, find & filter by file type
   my @directory_or_file_paths;
   for my $lane_obj (@lanes)
   {
      my $path = $pathtrack->hierarchy_path_of_lane($lane_obj,$hierarchy_template);
		  my $full_path = "$root/$path";
      next unless(-d $full_path);
      if(defined($file_type) && defined $file_types{$file_type})
      {
        push(@directory_or_file_paths, find_files_by_type($file_types{$file_type},$full_path));
      }
      else
      {
        push(@directory_or_file_paths,$full_path);
      }
   }
   
   # symlink
   if(defined $symlink)
   {
     for my $filtered_path (@directory_or_file_paths)
     {
       `ln -s $filtered_path `;
       if($filtered_path =~ /.bam$/)
       {
         `ln -s $filtered_path.bai `;
       }
       
     }
   }
   
   # print out the paths
   for my $filtered_path(@directory_or_file_paths)
   {
      print $filtered_path."\n";
      $found = 1;
   }

   $dbh->disconnect();
   if( $found ) #no need to look in the next database if relevant data has been found
   {
      exit;
   }
}

unless ($found) {

    print "Could not find lanes or files for input data \n";

}

sub find_files_by_type
{
  my($type, $base_path) = @_;
  
  opendir(DIR,$base_path);
  my @filenames = grep { /$type/i } 
  readdir(DIR);
  closedir(DIR);
  for(my $i = 0; $i < @filenames ; $i++)
  {
    $filenames[$i] = $base_path.'/'.$filenames[$i];
  }
  
  return @filenames;
} 

