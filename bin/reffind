#!/usr/bin/env perl

=head1 NAME

reffind

=head1 SYNOPSIS

# find reference directories
reffind -s "Aedes"
reffind -s "Salmonella Typhi"
reffind -s "Aedes" -symlink

# find reference files by type
reffind -s "Aedes" -f gff 
reffind -s "Aedes" -f embl 
reffind -s "Aedes" -f fa

# symlink to reference files
reffind -s "Aedes" -f gff -symlink
reffind -s "Aedes" -f embl -symlink
reffind -s "Aedes" -f fa -symlink

=head1 DESCRIPTION

Given a species return a the location of the references that match.

=head1 CONTACT

path-help@sanger.ac.uk

=head1 METHODS

=cut

use strict;
use warnings;
no warnings 'uninitialized';
use lib "/software/pathogen/internal/prod/lib";
use lib "../lib";

use Cwd;
use Cwd 'abs_path';
use Getopt::Long;
use Path::Find::Linker;
use Path::Find::Log;
eval {
    Path::Find::Log->new(
        logfile => '/nfs/pathnfs05/log/pathfindlog/reffind.log',
        args    => \@ARGV
    )->commandline();
};

my ( $species, $filetype, $symlink, $archive, $help );

GetOptions(
    's|species=s'  => \$species,
    'f|filetype=s' => \$filetype,
    'l|symlink:s'  => \$symlink,
	'a|archive:s'  => \$archive,
    'h|help'       => \$help,
);

(
    $species
      && (
        !$filetype
        || ( $filetype
            && (   $filetype eq 'fa'
                || $filetype eq 'gff'
                || $filetype eq 'embl' ) )
      )
) or die <<USAGE;

Usage: $0
     -s|species         <Species or regex>
     -f|filetype        <fa|gff|embl>
     -l|symlink         <create a symlink to the data>
	 -a|archive         <create an archive of the data>
     -h|help            <print this message>

Given a species or a partial name of a species, this script will output the path (on pathogen disk) to the reference. 
Using the option -filetype (fa, gff, or embl) will 
return the path to the files of this type for the given data. 
Using the option -l|symlink will create a symlink to the queried data. 
Using the option -a|archive will create an archive of the queried data.
For both -l and -a, a destination may be specified or a default will be created in the current directory.

Examples:
reffind -s bongori -l bongori_links 
creates symlinks in a directory called bongori_links
reffind -s bongori -a 
creates an archive with a default name in the current directory

USAGE

die "The archive and symlink options cannot be used together\n"
  if ( defined $archive && defined $symlink );

my $found = 0;    #assume nothing found

my $root       = '/lustre/scratch108/pathogen/pathpipe/refs/';
my $index_file = '/lustre/scratch108/pathogen/pathpipe/refs/refs.index';

my @references = search_index_file_for_directories( $index_file, $species );

if ( @references >= 1 ) {
    $found = 1;
    @references = find_files_of_given_type( @references, $filetype )
      if ( defined $filetype );
    sym_archive(@references) if ( defined $symlink || defined $archive );
    print_references(@references);
}

unless ($found) {
    print "Could not find references\n";
}

sub find_files_of_given_type {
    my ( $reference_directories, $filetype ) = @_;
    my @found_files;
    $found = 0;
    for my $directory (@$reference_directories) {
        opendir( DIR, $directory );
        my @files = grep { /$filetype$/i } readdir(DIR);
        for my $file (@files) {
            push( @found_files, $directory . '/' . $file );
            $found = 1;
        }
        closedir(DIR);
    }
    @found_files = remove_duplicates(@found_files);
    return \@found_files;
}

sub print_references {
    my ($references) = @_;
    for my $reference (@$references) {
        print $reference. "\n";
    }
}

sub sym_archive {
	my ($objects_to_link) = @_;
	
	my $name;
    if ( defined $symlink ) {
        $name = $symlink;
    }
    elsif ( defined $archive ) {
        $name = $archive;
    }
    $name = "reffind_$species" if ( $name eq '' );

	my $links = format_for_links($objects_to_link);
    my $linker = Path::Find::Linker->new(
        lanes            => $links,
        name             => $name,
    );

    $linker->sym_links if ( defined $symlink );
    $linker->archive   if ( defined $archive );
}

sub format_for_links {
	my ($objects_to_link) = @_;
	
	my @refs;
	foreach my $r ( @{ $objects_to_link } ){
		push(@refs, { path => abs_path($r) });
	}
	return \@refs;
}

sub search_index_file_for_directories {
    my ( $index_file, $search_query ) = @_;
    my @search_results;
    $search_query =~ s! !|!gi;

    open( INDEX_FILE, $index_file ) or die 'Couldnt find the refs.index file';
    while (<INDEX_FILE>) {
        chomp;
        my $line = $_;
        if ( $line =~ m/$search_query/i ) {
            if ( $line =~ m!\t(.+)/[^/]+fa$! ) {
                my $directory = $1;
                push( @search_results, $directory ) if ( -d $directory );
            }
        }
    }

    close(INDEX_FILE);

    return \@search_results;
}

sub remove_duplicates {
    my @file_list = @_;
    my %file_hash;

    foreach my $file ( sort @file_list ) {
        $file_hash{$file} = 1;
    }

    return sort keys %file_hash;
}
