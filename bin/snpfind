#!/usr/bin/env perl

=head1 NAME

snpfind

=head1 SYNOPSIS

snpfind -t study -id "My study name"
snpfind -t lane -id 1234_5#6

=head1 DESCRIPTION

Given a lane id, a study id or a study name, it will return the paths to the VCF files.

=head1 CONTACT

path-help@sanger.ac.uk

=head1 METHODS

=cut

use strict;
use warnings;
no warnings 'uninitialized';

use Cwd;
use File::chdir;
use File::Temp;
use File::Copy qw(move);
use Getopt::Long;
use lib "/software/pathogen/internal/pathdev/vr-codebase/modules"
  ;    #Change accordingly once we have a stable checkout
use lib "/software/pathogen/internal/prod/lib";
use lib "../lib";

use Path::Find;
use Path::Find::Lanes;
use Path::Find::Filter;
use Path::Find::Linker;
use Path::Find::Stats;
use Path::Find::Log;
eval {
    Path::Find::Log->new(
        logfile => '/nfs/pathnfs05/log/pathfindlog/snpfind.log',
        args    => \@ARGV
    )->commandline();
};

my (
    $type,    $id,           $symlink,  $archive, $help,
    $verbose, $stats,        $filetype, $ref,     $date,
    $mapper,  $pseudogenome, $qc
);

GetOptions(
    't|type=s'      => \$type,
    'i|id=s'        => \$id,
    'h|help'        => \$help,
    'f|filetype=s'  => \$filetype,
    'l|symlink:s'   => \$symlink,
    'a|archive:s'   => \$archive,
    's|stats:s'     => \$stats,
    'v|verbose'     => \$verbose,
    'r|reference=s' => \$ref,
    'd|date=s'      => \$date,
    'm|mapper=s'    => \$mapper,
    'p|pseudo=s'    => \$pseudogenome,
    'q|qc=s'        => $qc
);

(
         $type
      && $id
      && $id ne ''
      && ( $type eq 'study'
        || $type eq 'lane'
        || $type eq 'sample'
        || $type eq 'file'
        || $type eq 'species'
        || $type eq 'database' )
      && ( !$filetype || $filetype eq 'vcf' || $filetype eq 'pseudogenome' )
) or die <<USAGE;

Usage: $0
     -t|type      <study|lane|file|sample|species>
     -i|id        <study id|study name|lane name|file of lane names>
     -f|filetype  <vcf|pseudogenome>
     -q|qc        <pass|failed|pending>
     -l|symlink   <create a symlink to the data>
     -a|arvhive   <archive the data>
     -v|verbose   <display reference, mapper and date>
     -s|stats     <output file for summary of mapping results in CSV format>
     -r|reference <filter results based on reference>
     -m|mapper    <filter results based on mapper>
     -d|date      <show only results produced after a given date>
     -p|pseudo    <generate a pseudogenome based on the given reference (-r)>
     -h|help      <print this message>

Given a study, lane or a file containing a list of lanes, this script will output the path (on pathogen disk) to the VCF files with the specified study or lane. Using the option -qc (passed|failed|pending) will limit the 
results to data of the specified qc status. Using the option -symlink will create a symlink to the queried data in the current 
directory, alternativley an output directory can be specified in which the symlinks will be created.
Using the option -archive will create an archive (.tar.gz) containing the VCF and index files.

USAGE

die "The archive and symlink options cannot be used together\n"
  if ( defined $archive && defined $symlink );

die "Please specify a reference to base the pseudogenome on\n"
  if ( defined $pseudogenome && !defined $ref );

# set file type extension regular expressions
my %type_extensions = (
    vcf          => '*.markdup.snp/mpileup.unfilt.vcf.gz',
    pseudogenome => '*.markdup.snp/pseudo_genome.fasta'
);

my ( $lane_filter, $vb );
my $found = 0;

# Get databases and loop through them
my @pathogen_databases = Path::Find->pathogen_databases;
for my $database (@pathogen_databases) {

    # Connect to database and get info
    my ( $pathtrack, $dbh, $root ) = Path::Find->get_db_info($database);

    my $find_lanes = Path::Find::Lanes->new(
        search_type    => $type,
        search_id      => $id,
        pathtrack      => $pathtrack,
        dbh            => $dbh,
        processed_flag => 256
    );
    my @lanes = @{ $find_lanes->lanes };

    unless (@lanes) {
        $dbh->disconnect();
        next;
    }

    my $reference_added = 0;

    # filter lanes
    $filetype = "bam" if ( $verbose || $date || $ref || $mapper );
    $lane_filter = Path::Find::Filter->new(
        lanes           => \@lanes,
        filetype        => $filetype,
        root            => $root,
        pathtrack       => $pathtrack,
        type_extensions => \%type_extensions,
        reference       => $ref,
        mapper          => $mapper,
        date            => $date
    );
    my @matching_lanes = $lane_filter->filter;

    # Set up to symlink/archive. Check whether default filetype should be used
    my $use_default = 0;
    $use_default = 1 if ( !defined $filetype );
    if ( $lane_filter->found && ( $symlink || $archive ) ) {
        my $name;
        if ( defined $symlink ) {
            $name = $symlink;
        }
        elsif ( defined $archive ) {
            $name = $archive;
        }
        $name = "tradisfind_$id" if ( $name eq '' );

        my $linker = Path::Find::Linker->new(
            lanes            => \@matching_lanes,
            name             => $name,
            use_default_type => $use_default
        );

        $linker->sym_links if ($symlink);
        $linker->archive   if ($archive);
    }

    if (@matching_lanes) {
		$found = 1;
        if ($verbose) {
            foreach my $ml (@matching_lanes) {
				my $l = $ml->{lane};
				my $r = $ml->{ref};
				my $m = $ml->{mapper};
				my $d = $ml->{date};
                print "$l\t$r\t$m\t$d\n";
            }
        }
        else {
            foreach my $ml (@matching_lanes) {
				my $l = $ml->{lane};
                print "$l\n";
            }
        }
    }
	
    $dbh->disconnect();
    #no need to look in the next database if relevant data has been found
    exit if ($found);
}

unless ($found) {

    print "Could not find lanes or files for input data \n";

}

sub make_pseudogenome {
	#sticks all pseudo-genomes together into a concatenated fastq file
    my $pseudo_genome_filename = "concatenated";
    if ( defined($pseudo_genome) ) {
        if ( defined($target_reference) ) {
            $pseudo_genome_filename =
              $target_reference . "_" . $pseudo_genome_filename;
        }

        $pseudo_genome_filename = $id . "_" . $pseudo_genome_filename;
        $pseudo_genome_filename =~ s![\W]!_!gi;
        $pseudo_genome_filename .= '.aln';
        `touch $pseudo_genome_filename`;
    }


	#Â Add the reference if its defined
    if ( defined($target_reference) && $reference_added < 1 ) {
        my $reference_path = find_reference($target_reference);
        if ( defined($reference_path) ) {
            print_out_reference_as_one_sequence(
                $reference_path, $pseudo_genome_filename,
                $target_reference );
        }
        $reference_added++;
    }

    my @pseudo_genome_filenames;
    push(
        @pseudo_genome_filenames,
        pseudo_genome_filename(
            $l, 'markdup', $root, $path, $mapstat_id
        )
    );
    push(
        @pseudo_genome_filenames,
        pseudo_genome_filename(
            $l, 'raw.sorted', $root, $path, $mapstat_id
        )
    );
    for my $full_path (@pseudo_genome_filenames) {
        last if ( $mapstats_counter > 0 );
        if ( -e "$full_path" ) {
            $found = 1;
            $mapstats_counter++;
            if ( defined($pseudo_genome) ) {
                print "$full_path\n";
                `cat $full_path >> $pseudo_genome_filename`;
            }
        }
    }

}

sub find_reference {
    my $passed_in_reference = shift;
    return undef unless ( defined($passed_in_reference) );
    my $index_file = '/lustre/scratch108/pathogen/pathpipe/refs/refs.index';

    open( my $fh, $index_file ) or die 'Couldnt open index file';
    while (<$fh>) {
        chomp;
        my $line         = $_;
        my $search_query = $passed_in_reference . '.fa$';
        if ( $line =~ m/$search_query/i ) {
            my @ref_details = split( /\t/, $line );
            if ( -e $ref_details[1] ) {
                return $ref_details[1];
            }
        }
    }
    return undef;
}

sub print_out_reference_as_one_sequence {
    my ( $reference_file, $output_file, $reference_name ) = @_;
    open( my $in_fh, $reference_file );

    # Overwrite a file if it already exists because the reference is at the top
    open( my $out_fh, '>', $output_file );
    print {$out_fh} ">$reference_name\n";
    while (<$in_fh>) {
        my $line = $_;
        next if ( $line =~ />/ );
        print {$out_fh} $line;
    }
    close($in_fh);
    close($out_fh);
}

sub snp_calling_filename {
    my $lane       = shift;
    my $suffix     = shift;
    my $root       = shift;
    my $path       = shift;
    my $mapstat_id = shift;

    return base_snp_path( $lane, $suffix, $root, $path, $mapstat_id )
      . '/mpileup.unfilt.vcf.gz';
}

sub pseudo_genome_filename {
    my $lane       = shift;
    my $suffix     = shift;
    my $root       = shift;
    my $path       = shift;
    my $mapstat_id = shift;

    return base_snp_path( $lane, $suffix, $root, $path, $mapstat_id )
      . '/pseudo_genome.fasta';

}

sub base_snp_path {
    my $lane       = shift;
    my $suffix     = shift;
    my $root       = shift;
    my $path       = shift;
    my $mapstat_id = shift;

    my $reads_type;
    if ( $lane->is_paired() ) {
        $reads_type = 'pe';
    }
    else {
        $reads_type = 'se';
    }

    return
        "$root/$path/"
      . $mapstat_id . '.'
      . $reads_type . '.'
      . $suffix . '.snp';
}

sub does_mapping_match_target_reference {
    my ( $target_reference, $mapstat ) = @_;
    return 1 unless defined($target_reference);

    my $assembly = $mapstat->assembly();
    return 0 unless ( defined($assembly) );

    $target_reference =~ s!\W!.+!gi;
    return 1 if ( $assembly->name =~ m/$target_reference$/ );

    return 0;
}

sub create_vcf_symlinks {
    my $destination = $_[0];
    my $lane_name   = $_[1];
    my $mapstat_id  = $_[2];
    my $full_path   = $_[3];

    my $destination_directory =
        $destination . "/"
      . $lane_name . "."
      . $mapstat_id
      . ".mpileup.unfilt.vcf.gz";
    my $cmd = qq[ ln -s $full_path $destination_directory];
    qx( $cmd );

    my $full_path_index_file = $full_path . ".tbi";
    if ( -e "$full_path_index_file" ) {
        $destination_directory = $destination_directory . ".tbi";
        $cmd = qq[ ln -s $full_path_index_file $destination_directory];
        qx( $cmd );
    }
}

# Set archive_path, archive_name and archive_suffix
sub set_archive_name {
    my ($archive_submitted_name) = @_;
    my ( @path, $path, $name, $suff );

    @path = split( /\//, $archive_submitted_name );
    $name = pop @path;
    $path = scalar @path ? join( '/', @path ) . '/' : '';

    $name =~ m/(\.tgz|\.tar\.gz)$/;
    $suff = $1 ? $1 : '.tar.gz';
    $name =~ s/\.tgz$|\.tar\.gz$//;

    $name =~ s/\s+/_/gi;    # replace whitespace in name

    # verify output directory
    if ( $path && !( -d $path && -e $path ) ) {
        chop $path;         # remove '/'
        print "Error: Cannot find directory: $path\n";
        exit;
    }

    return ( $path, $name, $suff );
}

# Create archive for lanes
# Note: The tar command has to be run in the temporary directory.
sub archive_vcf {
    my ( $tmpdirectory_name, $archive_name, $archive_full ) = @_;
    my $error = 0;

    # create compressed tar archive in temporary directory
    # tar follows lane symlinks
    {
        local $CWD = $tmpdirectory_name;
        print "Archiving lanes:\n";
        system("tar -cvahf archive.tar.gz $archive_name") == 0 or $error = 1;
    }

    # return without moving archive if error during creation
    if ($error) {
        print "An error occured while creating the archive: $archive_name\n";
        print "No output written to $archive_full\n";
        return 0;
    }

    # move temp archive to archive destination
    move( $tmpdirectory_name . '/archive.tar.gz', $archive_full ) or $error = 1;

    print "An error occured while writing $archive_full: $!\n" if $error;
    return $error;
}

sub set_archive_name_from_id {
    my ( $id, $type ) = @_;

    # only remove path for 'file' some studies have '/' in title.
    my @path = split( /\//, $id );
    my $name = $type eq 'file' ? pop @path : $id;
    $name =~ s/\s+/_/gi;
    $name =~ s/[^\w\.]+/_/gi;

    return $name;
}
