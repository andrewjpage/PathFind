#!/usr/bin/env perl

=head1 NAME

snpfind

=head1 SYNOPSIS

snpfind -t study -id "My study name"
snpfind -t lane -id 1234_5#6

=head1 DESCRIPTION

Given a lane id, a study id or a study name, it will return the paths to the VCF files.

=head1 CONTACT

path-help@sanger.ac.uk

=head1 METHODS

=cut

use strict;
use warnings;
no warnings 'uninitialized';

use Cwd;
use File::chdir;
use File::Temp;
use File::Copy qw(move);
use Getopt::Long;
use lib "/software/pathogen/internal/pathdev/vr-codebase/modules"
  ;    #Change accordingly once we have a stable checkout
use lib "/software/pathogen/internal/prod/lib";
use lib "../lib";

use Path::Find;
use Path::Find::Lanes;
use Path::Find::Filter;
use Path::Find::Linker;
use Path::Find::Stats;
use Path::Find::Log;
eval {
    Path::Find::Log->new(
        logfile => '/nfs/pathnfs05/log/pathfindlog/snpfind.log',
        args    => \@ARGV
    )->commandline();
};

my (
    $type,    $id,           $symlink,  $archive, $help,
    $verbose, $stats,        $filetype, $ref,     $date,
    $mapper,  $pseudogenome, $qc
);

GetOptions(
    't|type=s'      => \$type,
    'i|id=s'        => \$id,
    'h|help'        => \$help,
    'f|filetype=s'  => \$filetype,
    'l|symlink:s'   => \$symlink,
    'a|archive:s'   => \$archive,
    's|stats:s'     => \$stats,
    'v|verbose'     => \$verbose,
    'r|reference=s' => \$ref,
    'd|date=s'      => \$date,
    'm|mapper=s'    => \$mapper,
    'p|pseudo=s'    => \$pseudogenome,
    'q|qc=s'        => $qc
);

(
         $type
      && $id
      && $id ne ''
      && ( $type eq 'study'
        || $type eq 'lane'
        || $type eq 'sample'
        || $type eq 'file'
        || $type eq 'species'
        || $type eq 'database' )
      && ( !$filetype || $filetype eq 'vcf' || $filetype eq 'pseudogenome' )
) or die <<USAGE;

Usage: $0
     -t|type      <study|lane|file|sample|species>
     -i|id        <study id|study name|lane name|file of lane names>
     -f|filetype  <vcf|pseudogenome>
     -q|qc        <pass|failed|pending>
     -l|symlink   <create a symlink to the data>
     -a|arvhive   <archive the data>
     -v|verbose   <display reference, mapper and date>
     -s|stats     <output file for summary of mapping results in CSV format>
     -r|reference <filter results based on reference>
     -m|mapper    <filter results based on mapper>
     -d|date      <show only results produced after a given date>
     -p|pseudo    <generate a pseudogenome based on the given reference (-r)>
     -h|help      <print this message>

Given a study, lane or a file containing a list of lanes, this script will output the path (on pathogen disk) to the VCF files with the specified study or lane. Using the option -qc (passed|failed|pending) will limit the 
results to data of the specified qc status. Using the option -symlink will create a symlink to the queried data in the current 
directory, alternativley an output directory can be specified in which the symlinks will be created.
Using the option -archive will create an archive (.tar.gz) containing the VCF and index files.

USAGE

die "The archive and symlink options cannot be used together\n"
  if ( defined $archive && defined $symlink );

die "Please specify a reference to base the pseudogenome on\n"
  if ( defined $pseudogenome && !defined $ref );

# set file type extension regular expressions
my %type_extensions = (
    vcf          => '*.markdup.snp/mpileup.unfilt.vcf.gz',
    pseudogenome => '*.markdup.snp/pseudo_genome.fasta'
);

my ( $lane_filter, $vb );
my $found = 0;

# Get databases and loop through them
my @pathogen_databases = Path::Find->pathogen_databases;
for my $database (@pathogen_databases) {

    # Connect to database and get info
    my ( $pathtrack, $dbh, $root ) = Path::Find->get_db_info($database);

	print "Path::Find::Lanes\n";
    my $find_lanes = Path::Find::Lanes->new(
        search_type    => $type,
        search_id      => $id,
        pathtrack      => $pathtrack,
        dbh            => $dbh,
        processed_flag => 256
    );
    my @lanes = @{ $find_lanes->lanes };

    unless (@lanes) {
        $dbh->disconnect();
        next;
    }

	print "Path::Find::Filter\n";
    # filter lanes
    $filetype = "bam" if ( $verbose || $date || $ref || $mapper );
    $lane_filter = Path::Find::Filter->new(
        lanes           => \@lanes,
        filetype        => $filetype,
        root            => $root,
        pathtrack       => $pathtrack,
        type_extensions => \%type_extensions,
        reference       => $ref,
        mapper          => $mapper,
        date            => $date
    );
    my @matching_lanes = $lane_filter->filter;

	print "Path::Find::Linker\n";
    # Set up to symlink/archive. Check whether default filetype should be used
    my $use_default = 0;
    $use_default = 1 if ( !defined $filetype );
    if ( $lane_filter->found && ( $symlink || $archive ) ) {
        my $name;
        if ( defined $symlink ) {
            $name = $symlink;
        }
        elsif ( defined $archive ) {
            $name = $archive;
        }
        $name = "snpfind_$id" if ( $name eq '' );

        my $linker = Path::Find::Linker->new(
            lanes            => \@matching_lanes,
            name             => $name,
            use_default_type => $use_default
        );

        $linker->sym_links if ($symlink);
        $linker->archive   if ($archive);
    }

    if (@matching_lanes) {
		$found = 1;
        if ($verbose) {
            foreach my $ml (@matching_lanes) {
				my $l = $ml->{lane};
				my $r = $ml->{ref};
				my $m = $ml->{mapper};
				my $d = $ml->{date};
                print "$l\t$r\t$m\t$d\n";
            }
        }
        else {
            foreach my $ml (@matching_lanes) {
				my $l = $ml->{lane};
                print "$l\n";
            }
        }
    }
	
    $dbh->disconnect();
    #no need to look in the next database if relevant data has been found
    exit if ($found);
}

unless ($found) {

    print "Could not find lanes or files for input data \n";

}