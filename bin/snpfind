#!/usr/bin/env perl

=head1 NAME

snpfind

=head1 SYNOPSIS

snpfind -t study -id "My study name"
snpfind -t lane -id 1234_5#6

=head1 DESCRIPTION

Given a lane id, a study id or a study name, it will return the paths to the VCF files.

=head1 CONTACT

path-help@sanger.ac.uk

=head1 METHODS

=cut

use strict;
use warnings;
no warnings 'uninitialized';

use Cwd;
use File::chdir;
use File::Temp;
use File::Copy qw(move);
use lib "/software/pathogen/internal/pathdev/vr-codebase/modules";    #Change accordingly once we have a stable checkout
use lib "/software/pathogen/internal/prod/lib";
use Getopt::Long;
use Pathfind;
use FindLanes;
use PathfindLog;
eval{ PathfindLog->new(logfile => '/nfs/pathnfs05/log/pathfindlog/snpfind.log', args => \@ARGV)->commandline(); };

my ( $type, $id, $qc, $symlink, $output, $pseudo_genome, $help, $target_reference, $archive );

GetOptions(
    't|type=s'        => \$type,
    'id=s'            => \$id,
    'qc=s'            => \$qc,
    'symlink'         => \$symlink,
    'p|pseudo_genome' => \$pseudo_genome,
    'r|reference=s'   => \$target_reference,
    'o|output=s'      => \$output,
    'a|archive:s'     => \$archive,
    'h|help'          => \$help,
);

(        $type
      && $id
      && $id ne ''
      && ( $type eq 'study' || $type eq 'lane' || $type eq 'file'|| $type eq 'sample'  || $type eq 'species' || $type eq 'database')
      && ( !$qc || ( $qc && ( $qc eq 'passed' || $qc eq 'failed' || $qc eq 'pending' ) ) ) )
  or die <<USAGE;

Usage: $0
     -t|type  		<study|lane|file|sample|species>
     -id 		<study id|study name|lane name|file of lane names>
     -qc      		<passed|failed|pending>
     -r           <reference name to filter on>
     -p           <pseudo genome>
     -symlink 		<create a symlink to the data>
     -o|output 		<output dir for sym links>
     -a|archive         <name of archive>
     -h|help  		<print this message>

Given a study, lane or a file containing a list of lanes, this script will output the path (on pathogen disk) to the VCF files with the specified study or lane. Using the option -qc (passed|failed|pending) will limit the 
results to data of the specified qc status. Using the option -symlink will create a symlink to the queried data in the current 
directory, alternativley an output directory can be specified in which the symlinks will be created.
Using the option -archive will create an archive (.tar.gz) containing the VCF and index files.

USAGE

# Get databases
my @pathogen_databases = Pathfind->pathogen_databases;
my $hierarchy_template = Pathfind->hierarchy_template;

my $pathtrack;
my $found = 0;    #assume nothing found
my $min   = 0;
my $max   = 1;
my $destination;

if ($symlink) {
    $destination = defined($output) ? $output : getcwd;
    if ( !-e $destination ) {
        print
"The directory $destination does not exist, please specify a valid destination output directory for the symlinks";
        exit;
    }
}

# set archive name from $id
my $archive_from_id = set_archive_name_from_id( $id, $type );
$archive_from_id .= '.snp.tar.gz';

# option for user-defined archive name
my $archive_name_input = ( defined($archive) && $archive ) ? $archive : $archive_from_id;

# set archive path folder_name and suffix
my ( $archive_path, $archive_name, $archive_suffix ) = set_archive_name($archive_name_input);

for my $database (@pathogen_databases) {

    # Connect to database
    $pathtrack = Pathfind->instantiate_vrtrack($database) or die "Failed to create VRTrack object for '$database'\n";
    my $dbh  = Pathfind->instantiate_dbi($database)    or die "Failed to create DBI object for '$database'\n";
    my $root = Pathfind->hierarchy_root_dir($database) or die "Failed to find root directory for '$database'\n";

    my $find_lanes = FindLanes->new(
        search_type => $type,
        search_id   => $id,
        pathtrack   => $pathtrack,
        dbh         => $dbh,
        processed_flag => 256
    );
    my @lanes = @{ $find_lanes->lanes };

    my $tmpdirectory;
    my $tmpdirectory_name = '';
    if ( defined $archive ) {

        # create temporary directory for archive
        $tmpdirectory = File::Temp->newdir( CLEANUP => 1 );
        $tmpdirectory_name = $tmpdirectory->dirname();
        mkdir $tmpdirectory_name . '/' . $archive_name;
    }

    foreach (@lanes) {
        my $l = $_;
        if ( !$qc || ( $qc && $qc eq $l->qc_status() ) ) {
            my $path = $pathtrack->hierarchy_path_of_lane( $l, $hierarchy_template );

            my $pseudo_genome_filename = "concatenated";
            if ( defined($pseudo_genome) ) {
                if ( defined($target_reference) ) {
                    $pseudo_genome_filename = $target_reference . "_" . $pseudo_genome_filename;
                }

                $pseudo_genome_filename = $id . "_" . $pseudo_genome_filename;
                $pseudo_genome_filename =~ s![\W]!_!gi;
                $pseudo_genome_filename .= '.aln';
                `touch $pseudo_genome_filename`;
            }

            for my $mapstat ( @{ $l->mappings() } ) {
                my $mapstat_id = $mapstat->id;

                next unless ( does_mapping_match_target_reference( $target_reference, $mapstat ) );

                my $lane_name = $l->name;

                unless ( defined($pseudo_genome) ) {
                    my @filenames;
                    push( @filenames, snp_calling_filename( $l, 'markdup',    $root, $path, $mapstat_id ) );
                    push( @filenames, snp_calling_filename( $l, 'raw.sorted', $root, $path, $mapstat_id ) );

                    for my $full_path (@filenames) {

                        if ( -e "$full_path" ) {
                            $found = 1;
                            print "$full_path\n";
                            if ($symlink) {
                                create_vcf_symlinks( $destination, $lane_name, $mapstat_id, $full_path );
                            }

                            if ( defined $archive ) {
                                my $tmpdir = $tmpdirectory_name . '/' . $archive_name;
                                create_vcf_symlinks( $tmpdir, $lane_name, $mapstat_id, $full_path );
                            }
                            last;
                        }
                    }
                }
                else {
                    my @pseudo_genome_filenames;
                    push( @pseudo_genome_filenames,
                        pseudo_genome_filename( $l, 'markdup', $root, $path, $mapstat_id ) );
                    push( @pseudo_genome_filenames,
                        pseudo_genome_filename( $l, 'raw.sorted', $root, $path, $mapstat_id ) );
                    for my $full_path (@pseudo_genome_filenames) {

                        if ( -e "$full_path" ) {
                            $found = 1;
                            if ( defined($pseudo_genome) ) {
                                print "$full_path\n";
                                `cat $full_path >> $pseudo_genome_filename`;
                            }
                        }
                    }
                }
            }
        }
    }

    $dbh->disconnect();
    if ($found)    #no need to look in the next database if relevant data has been found
    {
        if ( defined $archive ) {
            archive_vcf( $tmpdirectory_name, $archive_name, $archive_path . $archive_name . $archive_suffix );
        }

        exit;
    }
}

unless ($found) {

    print "Could not find lanes or files for input data \n";

}

sub snp_calling_filename {
    my $lane       = shift;
    my $suffix     = shift;
    my $root       = shift;
    my $path       = shift;
    my $mapstat_id = shift;

    return base_snp_path( $lane, $suffix, $root, $path, $mapstat_id ) . '/mpileup.unfilt.vcf.gz';
}

sub pseudo_genome_filename {
    my $lane       = shift;
    my $suffix     = shift;
    my $root       = shift;
    my $path       = shift;
    my $mapstat_id = shift;

    return base_snp_path( $lane, $suffix, $root, $path, $mapstat_id ) . '/pseudo_genome.fasta';

}

sub base_snp_path {
    my $lane       = shift;
    my $suffix     = shift;
    my $root       = shift;
    my $path       = shift;
    my $mapstat_id = shift;

    my $reads_type;
    if ( $lane->is_paired() ) {
        $reads_type = 'pe';
    }
    else {
        $reads_type = 'se';
    }

    return "$root/$path/" . $mapstat_id . '.' . $reads_type . '.' . $suffix . '.snp';
}

sub does_mapping_match_target_reference {
    my ( $target_reference, $mapstat ) = @_;
    return 1 unless defined($target_reference);

    my $assembly = $mapstat->assembly();
    return 0 unless ( defined($assembly) );

    $target_reference =~ s!\W!.+!gi;
    return 1 if ( $assembly->name =~ m/$target_reference/ );

    return 0;
}

sub create_vcf_symlinks {
    my $destination = $_[0];
    my $lane_name   = $_[1];
    my $mapstat_id  = $_[2];
    my $full_path   = $_[3];

    my $destination_directory = $destination . "/" . $lane_name . "." . $mapstat_id . ".mpileup.unfilt.vcf.gz";
    my $cmd                   = qq[ ln -s $full_path $destination_directory];
    qx( $cmd );

    my $full_path_index_file = $full_path . ".tbi";
    if ( -e "$full_path_index_file" ) {
        $destination_directory = $destination_directory . ".tbi";
        $cmd                   = qq[ ln -s $full_path_index_file $destination_directory];
        qx( $cmd );
    }
}

# Set archive_path, archive_name and archive_suffix
sub set_archive_name {
    my ($archive_submitted_name) = @_;
    my ( @path, $path, $name, $suff );

    @path = split( /\//, $archive_submitted_name );
    $name = pop @path;
    $path = scalar @path ? join( '/', @path ) . '/' : '';

    $name =~ m/(\.tgz|\.tar\.gz)$/;
    $suff = $1 ? $1 : '.tar.gz';
    $name =~ s/\.tgz$|\.tar\.gz$//;

    $name =~ s/\s+/_/gi;    # replace whitespace in name

    # verify output directory
    if ( $path && !( -d $path && -e $path ) ) {
        chop $path;         # remove '/'
        print "Error: Cannot find directory: $path\n";
        exit;
    }

    return ( $path, $name, $suff );
}

# Create archive for lanes
# Note: The tar command has to be run in the temporary directory.
sub archive_vcf {
    my ( $tmpdirectory_name, $archive_name, $archive_full ) = @_;
    my $error = 0;

    # create compressed tar archive in temporary directory
    # tar follows lane symlinks
    {
        local $CWD = $tmpdirectory_name;
        print "Archiving lanes:\n";
        system("tar -cvahf archive.tar.gz $archive_name") == 0 or $error = 1;
    }

    # return without moving archive if error during creation
    if ($error) {
        print "An error occured while creating the archive: $archive_name\n";
        print "No output written to $archive_full\n";
        return 0;
    }

    # move temp archive to archive destination
    move( $tmpdirectory_name . '/archive.tar.gz', $archive_full ) or $error = 1;

    print "An error occured while writing $archive_full: $!\n" if $error;
    return $error;
}

sub set_archive_name_from_id {
    my ( $id, $type ) = @_;

    # only remove path for 'file' some studies have '/' in title.
    my @path = split( /\//, $id );
    my $name = $type eq 'file' ? pop @path : $id;
    $name =~ s/\s+/_/gi;
    $name =~ s/[^\w\.]+/_/gi;

    return $name;
}
