#!/usr/bin/env perl

=head1 NAME

snpfind

=head1 SYNOPSIS

snpfind -t study -id "My study name"
snpfind -t lane -id 1234_5#6

=head1 DESCRIPTION

Given a lane id, a study id or a study name, it will return the paths to the VCF files.

=head1 CONTACT

path-help@sanger.ac.uk

=head1 METHODS

=cut

use strict;
use warnings;
no warnings 'uninitialized';

use Cwd;
use File::chdir;
use File::Temp;
use File::Copy qw(move);
use Getopt::Long;
use lib "/software/pathogen/internal/pathdev/vr-codebase/modules"
  ;    #Change accordingly once we have a stable checkout
use lib "/software/pathogen/internal/prod/lib";
use lib "../lib";

use Path::Find;
use Path::Find::Lanes;
use Path::Find::Filter;
use Path::Find::Linker;
use Path::Find::Verbose;
use Path::Find::Stats;
use Path::Find::Log;
eval {
    Path::Find::Log->new(
        logfile => '/nfs/pathnfs05/log/pathfindlog/snpfind.log',
        args    => \@ARGV
    )->commandline();
};

my (
    $type,  $id,       $symlink, $archive, $help,   $verbose,
    $stats, $filetype, $ref,     $date,    $mapper, $qc
);

GetOptions(
    't|type=s'      => \$type,
    'i|id=s'        => \$id,
    'h|help'        => \$help,
    'f|filetype=s'  => \$filetype,
    'l|symlink:s'   => \$symlink,
    'a|archive:s'   => \$archive,
    's|stats:s'     => \$stats,
    'v|verbose'     => \$verbose,
    'r|reference=s' => \$ref,
    'd|date=s'      => \$date,
    'm|mapper=s'    => \$mapper,
    'q|qc=s'        => $qc
);

(
    $type && $id && $id ne '' && ( $type eq 'study'
        || $type eq 'lane'
        || $type eq 'sample'
        || $type eq 'file'
        || $type eq 'species'
        || $type eq 'database' )
) or die <<USAGE;

Usage: $0
     -t|type      <study|lane|file|sample|species>
     -i|id        <study id|study name|lane name|file of lane names>
     -f|filetype  <vcf|pseudogenome>
     -q|qc        <pass|failed|pending>
     -l|symlink   <create a symlink to the data>
     -a|arvhive   <archive the data>
     -v|verbose   <display reference, mapper and date>
     -s|stats     <output file for summary of mapping results in CSV format>
     -r|reference <filter results based on reference>
     -m|mapper    <filter results based on mapper>
     -d|date      <show only results produced after a given date>
     -h|help      <print this message>

Given a study, lane or a file containing a list of lanes, this script will output the path (on pathogen disk) to the VCF files with the specified study or lane. Using the option -qc (passed|failed|pending) will limit the 
results to data of the specified qc status. Using the option -symlink will create a symlink to the queried data in the current 
directory, alternativley an output directory can be specified in which the symlinks will be created.
Using the option -archive will create an archive (.tar.gz) containing the VCF and index files.

USAGE

die "The archive and symlink options cannot be used together\n"
  if ( defined $archive && defined $symlink );

# set file type extension regular expressions
my %type_extensions = ( 
	vcf => 'markdup\.bam$', 
	pseudogenome => ''
);

my ( $lane_filter, $vb );
my $found = 0;

# Get databases and loop through them
my @pathogen_databases = Path::Find->pathogen_databases;
for my $database (@pathogen_databases) {

    # Connect to database and get info
    my ( $pathtrack, $dbh, $root ) = Path::Find->get_db_info($database);

    my $find_lanes = Path::Find::Lanes->new(
        search_type    => $type,
        search_id      => $id,
        pathtrack      => $pathtrack,
        dbh            => $dbh,
        processed_flag => 256
    );
    my @lanes = @{ $find_lanes->lanes };

    unless (@lanes) {
        $dbh->disconnect();
        next;
    }

    foreach (@lanes) {
        my $l = $_;
        if ( !$qc || ( $qc && $qc eq $l->qc_status() ) ) {
            my $path =
              $pathtrack->hierarchy_path_of_lane( $l, $hierarchy_template );

            my $pseudo_genome_filename = "concatenated";
            if ( defined($pseudo_genome) ) {
                if ( defined($target_reference) ) {
                    $pseudo_genome_filename =
                      $target_reference . "_" . $pseudo_genome_filename;
                }

                $pseudo_genome_filename = $id . "_" . $pseudo_genome_filename;
                $pseudo_genome_filename =~ s![\W]!_!gi;
                $pseudo_genome_filename .= '.aln';
                `touch $pseudo_genome_filename`;
            }

            for my $mapstat ( @{ $l->mappings() } ) {
                my $mapstat_id = $mapstat->id;

                next
                  unless (
                    does_mapping_match_target_reference(
                        $target_reference, $mapstat
                    )
                  );

                my $lane_name = $l->name;

                unless ( defined($pseudo_genome) ) {
                    my @filenames;
                    push(
                        @filenames,
                        snp_calling_filename(
                            $l, 'markdup', $root, $path, $mapstat_id
                        )
                    );
                    push(
                        @filenames,
                        snp_calling_filename(
                            $l, 'raw.sorted', $root, $path, $mapstat_id
                        )
                    );

                    for my $full_path (@filenames) {

                        if ( -e "$full_path" ) {
                            $found = 1;
                            print "$full_path\n";
                            if ($symlink) {
                                create_vcf_symlinks(
                                    $destination, $lane_name,
                                    $mapstat_id,  $full_path
                                );
                            }

                            if ( defined $archive ) {
                                my $tmpdir =
                                  $tmpdirectory_name . '/' . $archive_name;
                                create_vcf_symlinks(
                                    $tmpdir,     $lane_name,
                                    $mapstat_id, $full_path
                                );
                            }
                            last;
                        }
                    }
                }
                else {
                    my @pseudo_genome_filenames;
                    push(
                        @pseudo_genome_filenames,
                        pseudo_genome_filename(
                            $l, 'markdup', $root, $path, $mapstat_id
                        )
                    );
                    push(
                        @pseudo_genome_filenames,
                        pseudo_genome_filename(
                            $l, 'raw.sorted', $root, $path, $mapstat_id
                        )
                    );
                    for my $full_path (@pseudo_genome_filenames) {

                        if ( -e "$full_path" ) {
                            $found = 1;
                            if ( defined($pseudo_genome) ) {
                                print "$full_path\n";
                                `cat $full_path >> $pseudo_genome_filename`;
                            }
                        }
                    }
                }
            }
        }
    }

    $dbh->disconnect();
    if ($found
      )    #no need to look in the next database if relevant data has been found
    {
        if ( defined $archive ) {
            archive_vcf( $tmpdirectory_name, $archive_name,
                $archive_path . $archive_name . $archive_suffix );
        }

        exit;
    }
}

unless ($found) {

    print "Could not find lanes or files for input data \n";

}

sub snp_calling_filename {
    my $lane       = shift;
    my $suffix     = shift;
    my $root       = shift;
    my $path       = shift;
    my $mapstat_id = shift;

    return base_snp_path( $lane, $suffix, $root, $path, $mapstat_id )
      . '/mpileup.unfilt.vcf.gz';
}

sub pseudo_genome_filename {
    my $lane       = shift;
    my $suffix     = shift;
    my $root       = shift;
    my $path       = shift;
    my $mapstat_id = shift;

    return base_snp_path( $lane, $suffix, $root, $path, $mapstat_id )
      . '/pseudo_genome.fasta';

}

sub base_snp_path {
    my $lane       = shift;
    my $suffix     = shift;
    my $root       = shift;
    my $path       = shift;
    my $mapstat_id = shift;

    my $reads_type;
    if ( $lane->is_paired() ) {
        $reads_type = 'pe';
    }
    else {
        $reads_type = 'se';
    }

    return
        "$root/$path/"
      . $mapstat_id . '.'
      . $reads_type . '.'
      . $suffix . '.snp';
}

sub does_mapping_match_target_reference {
    my ( $target_reference, $mapstat ) = @_;
    return 1 unless defined($target_reference);

    my $assembly = $mapstat->assembly();
    return 0 unless ( defined($assembly) );

    $target_reference =~ s!\W!.+!gi;
    return 1 if ( $assembly->name =~ m/$target_reference/ );

    return 0;
}

sub create_vcf_symlinks {
    my $destination = $_[0];
    my $lane_name   = $_[1];
    my $mapstat_id  = $_[2];
    my $full_path   = $_[3];

    my $destination_directory =
        $destination . "/"
      . $lane_name . "."
      . $mapstat_id
      . ".mpileup.unfilt.vcf.gz";
    my $cmd = qq[ ln -s $full_path $destination_directory];
    qx( $cmd );

    my $full_path_index_file = $full_path . ".tbi";
    if ( -e "$full_path_index_file" ) {
        $destination_directory = $destination_directory . ".tbi";
        $cmd = qq[ ln -s $full_path_index_file $destination_directory];
        qx( $cmd );
    }
}

# Set archive_path, archive_name and archive_suffix
sub set_archive_name {
    my ($archive_submitted_name) = @_;
    my ( @path, $path, $name, $suff );

    @path = split( /\//, $archive_submitted_name );
    $name = pop @path;
    $path = scalar @path ? join( '/', @path ) . '/' : '';

    $name =~ m/(\.tgz|\.tar\.gz)$/;
    $suff = $1 ? $1 : '.tar.gz';
    $name =~ s/\.tgz$|\.tar\.gz$//;

    $name =~ s/\s+/_/gi;    # replace whitespace in name

    # verify output directory
    if ( $path && !( -d $path && -e $path ) ) {
        chop $path;         # remove '/'
        print "Error: Cannot find directory: $path\n";
        exit;
    }

    return ( $path, $name, $suff );
}

# Create archive for lanes
# Note: The tar command has to be run in the temporary directory.
sub archive_vcf {
    my ( $tmpdirectory_name, $archive_name, $archive_full ) = @_;
    my $error = 0;

    # create compressed tar archive in temporary directory
    # tar follows lane symlinks
    {
        local $CWD = $tmpdirectory_name;
        print "Archiving lanes:\n";
        system("tar -cvahf archive.tar.gz $archive_name") == 0 or $error = 1;
    }

    # return without moving archive if error during creation
    if ($error) {
        print "An error occured while creating the archive: $archive_name\n";
        print "No output written to $archive_full\n";
        return 0;
    }

    # move temp archive to archive destination
    move( $tmpdirectory_name . '/archive.tar.gz', $archive_full ) or $error = 1;

    print "An error occured while writing $archive_full: $!\n" if $error;
    return $error;
}

sub set_archive_name_from_id {
    my ( $id, $type ) = @_;

    # only remove path for 'file' some studies have '/' in title.
    my @path = split( /\//, $id );
    my $name = $type eq 'file' ? pop @path : $id;
    $name =~ s/\s+/_/gi;
    $name =~ s/[^\w\.]+/_/gi;

    return $name;
}
