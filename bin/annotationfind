#!/usr/bin/env perl

=head1 NAME

annotationfind

=head1 SYNOPSIS

annotationfind -t study -id "My study name"
annotationfind -t lane -id 1234_5#6

=head1 DESCRIPTION

Given a lane id, a study id or a study name, it will return the paths to the annotation data

=head1 CONTACT

path-help@sanger.ac.uk

=head1 METHODS

=cut

use strict;
use warnings;
no warnings 'uninitialized';

use Cwd;

use lib "/software/pathogen/internal/pathdev/vr-codebase/modules"
  ;    #Change accordingly once we have a stable checkout
use lib "/software/pathogen/internal/prod/lib";
use lib "../lib";

#use File::Temp;
#use File::Copy qw(move);
use Getopt::Long;
use Bio::AutomatedAnnotation::ParseGenesFromGFFs;

use Path::Find;
use Path::Find::Lanes;
use Path::Find::Filter;
use Path::Find::Linker;
use Path::Find::Log;
eval {
    Path::Find::Log->new(
        logfile => '/nfs/pathnfs05/log/pathfindlog/annotationfind.log',
        args    => \@ARGV
    )->commandline();
};

my (
    $type,        $id,     $symlink, $help,
    $filetype,    $output, $gene,    $search_products,
    $nucleotides, $archive
);

GetOptions(
    't|type=s'          => \$type,
    'i|id=s'            => \$id,
    'h|help'            => \$help,
    'f|filetype=s'      => \$filetype,
    'l|symlink:s'       => \$symlink,
    'a|archive:s'       => \$archive,
    'g|gene=s'          => \$gene,
    'p|search_products' => \$search_products,
    'n|nucleotides'     => \$nucleotides,
);

(
         $type
      && $id
      && $id ne ''

      && ( $type eq 'study'
        || $type eq 'lane'
        || $type eq 'file'
        || $type eq 'sample'
        || $type eq 'species'
        || $type eq 'database' )
  )
  && (
    !$filetype
    || ( $filetype
        && ( $filetype eq 'gff' || $filetype eq 'faa' || $filetype eq 'ffn' ) )
  ) or die <<USAGE;


Usage: $0
  -t|type            <study|lane|file|sample|species>
  -i|id              <study id|study name|lane name|file of lane names>
  -l|symlink         <create a symlink to the data>
  -f|filetype       <gff|faa|ffn>
  -g|gene            <name of gene>
  -p|search_products <when searching for genes also search products>
  -o|output          <name of output fasta file of genes>
  -n|nucleotides     <output nucleotide sequence instead of amino acids in fasta file>
  -a|archive		 <name of archive>
  -h|help            <print this message>

Given a study or lane this will give you the location of the annotation results. By default it provides the directory, but by specifiying a 'filetype' you can narrow it down to particular 
files within the result set. 
Using the option -archive will create an archive (.tar.gz) containing the selected annotations. The -archive option will automatically name the archive file if a name is not supplied.
For an annotation you will have:

gff: The master annotation in GFF3 format, containing both sequences and annotations.
faa: The Protein FASTA file of the translated CDS sequences.
ffn: The Nucleotide FASTA file of the CDS sequences.

# Create a fasta file containing all of the gryA genes for Stap.
annotationfind -t species -i Stap -g gryA

# Output as nucleotide sequences instead of amino acids
annotationfind -t species -i Stap -g gryA -n 

# Create a fasta file containing all 16S for Strep.
annotationfind -t species -i Strep -g "16S ribosomal RNA" -p

# create a compressed archive containing all annotations for a study
annotationfind -t study -id 123 -archive 
annotationfind -t study -id 123 -archive study_123_annotations

USAGE

die "The archive and symlink options cannot be used together\n"
  if ( defined $archive && defined $symlink );

# Get databases
my @pathogen_databases = Path::Find->pathogen_databases;
my $lane_filter;

# set subdirectories to search for annotations in
my @sub_directories =
  ( '/velvet_assembly/annotation', '/spades_assembly/annotation' );

# set file type extension wildcard
my %type_extensions = (
    gff => '*.gff',
    faa => '*.faa',
    ffn => '*.ffn'
);

if ($gene) {
    $filetype = 'gff';
}

for my $database (@pathogen_databases) {

    # Connect to database and get info
    my ( $pathtrack, $dbh, $root ) = Path::Find->get_db_info($database);

    my $find_lanes = Path::Find::Lanes->new(
        search_type    => $type,
        search_id      => $id,
        pathtrack      => $pathtrack,
        dbh            => $dbh,
        processed_flag => 2048
    );
    my @lanes = @{ $find_lanes->lanes };

	unless (@lanes) {
        $dbh->disconnect();
        next;
    }

    # check directories exist, find & filter by file type
    $lane_filter = Path::Find::Filter->new(
        lanes           => \@lanes,
        filetype        => $filetype,
        type_extensions => \%type_extensions,
        root            => $root,
        pathtrack       => $pathtrack,
        subdirectories  => \@sub_directories
    );
    my @matching_lanes = $lane_filter->filter;

    # symlink or archive
    # Set up to symlink/archive. Check whether default filetype should be used
    my $use_default = 0;
    $use_default = 1 if ( !defined $filetype );
    if ( $lane_filter->found && ( defined $symlink || defined $archive ) ) {
        my $name;
        if ( defined $symlink ) {
            $name = $symlink;
        }
        elsif ( defined $archive ) {
            $name = $archive;
        }
        $name = "annotationfind_$id" if ( $name eq '' );

        my $linker = Path::Find::Linker->new(
            lanes            => \@matching_lanes,
            name             => $name,
            use_default_type => $use_default
        );

        $linker->sym_links if (defined $symlink);
        $linker->archive   if (defined $archive);
    }

    # print out the paths
    foreach my $ml (@matching_lanes) {
        my $l = $ml->{lane};
        print "$l\n";
    }

    if ( $lane_filter->found && defined($gene) ) {
        my $qualifiers_to_search = ['gene'];
        if ( defined($search_products) ) {
            push( @{$qualifiers_to_search}, 'product' );
            push( @{$qualifiers_to_search}, 'ID' );
        }
        my $amino_acids = 1;
        $amino_acids = 0 if ($nucleotides);
        my $gene_finder = Bio::AutomatedAnnotation::ParseGenesFromGFFs->new(
            gff_files         => \@matching_lanes,
            search_query      => $gene,
            search_qualifiers => $qualifiers_to_search,
            amino_acids       => $amino_acids
        );
        $gene_finder->create_fasta_file;

        print "Samples containing gene:\t"
          . $gene_finder->files_with_hits() . "\n";
        print "Samples missing gene:\t"
          . $gene_finder->files_without_hits() . "\n";
    }

    $dbh->disconnect();

    #no need to look in the next database if relevant data has been found
    if ( $lane_filter->found ) {

        #Path::Find::Stats->new()->write_stats;
        exit;
    }
}

unless ( $lane_filter->found ) {
    print "Could not find lanes or files for input data \n";
}
