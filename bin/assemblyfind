#!/usr/bin/env perl

=head1 NAME

assemblyfind

=head1 SYNOPSIS

assemblyfind -t lane -i 1234

=head1 DESCRIPTION

Given a lane id, this script returns the location on disk of the relevant fastq files

=head1 CONTACT

path-help@sanger.ac.uk

=head1 METHODS

=cut

use strict;
use warnings;
no warnings 'uninitialized';

use Cwd;
use Data::Dumper;

#Change accordingly once we have a stable checkout
use lib "/software/pathogen/internal/pathdev/vr-codebase/modules";

use lib "/software/pathogen/internal/prod/lib";
use lib "../lib";

use Getopt::Long;
use VertRes::Parser::bamcheck;
use Bio::MLST::Databases;
use File::Temp;
use File::chdir;
use File::Copy qw(move);

use Path::Find;
use Path::Find::Lanes;
use Path::Find::Filter;
use Path::Find::Linker;
use Path::Find::Log;
eval {
    Path::Find::Log->new(
        logfile => '/nfs/pathnfs05/log/pathfindlog/assemblyfind.log',
        args    => \@ARGV
    )->commandline();
};

my ( $type, $id, $symlink, $output, $stats, $filetype, $archive, $help );
my ( $qc, $found, $destination, $tmpdirectory_name, $archive_name, $all_stats,
    $archive_path, $archive_suffix );

GetOptions(
    't|type=s'     => \$type,
    'i|id=s'       => \$id,
    'h|help'       => \$help,
    'f|filetype=s' => \$filetype,
    'l|symlink:s'  => \$symlink,
    'a|archive:s'  => \$archive,
    's|stats'      => \$stats,
);

(
         $type
      && $id
      && $id ne ''
      && ( $type eq 'study'
        || $type eq 'lane'
        || $type eq 'file'
        || $type eq 'sample'
        || $type eq 'species'
        || $type eq 'database' )
      && (
        !$filetype
        || (
            $filetype
            && (   $filetype eq 'contigs'
                || $filetype eq 'scaffold' )
        )
      )
      && ( !defined($archive)
        || $archive eq ''
        || ( $archive && !( $stats || $symlink || $output ) ) )
) or die <<USAGE;

Usage: $0
     -t|type            <study|lane|file|sample|species>
     -id                <study id|study name|lane name|file of lane names>
     -qc                <passed|failed|pending>
     -symlink           <create a symlink to the data>
     -o|output          <output dir for sym links>
     -s|stats           <create a CSV file containing assembly stats>
     -a|archive         <name of archive>
     -stage             <auto|all|user|velvet|columbus|scaffold>
     -h|help            <print this message>

Given a study, lane or a file containing a list of lanes, this script will output the path (on pathogen disk) to the data associated with the specified study or lane. 
Using the option -symlink will create a symlink to the queried data in the current directory, alternativley an output directory can be specified in which the symlinks will be created.
Using the option -archive will create an archive (.tar.gz) containing the selected assemblies and a CSV file. The -archive option will automatically name the archive file if a name is not supplied.
Assemblies created by the assemble_lanes script can be found using the -stage option: 'all' will find all assemblies on disk, 'user' will find assemblies created by assemble_lanes and 'velvet','columbus' or 'scaffold' will find the assembly from the given stage of the assemble_lanes pipeline
The default value for -stage is 'auto' which will find assemblies produced by the automated pipeline.

# create symlinks to all the final assemblies in the given study
assemblyfind -t study -id "My study" -symlink

# find an assembly for a given lane
assemblyfind -t lane -id 1234_5#6 

# create a CSV file of assembly statistics for all assemblies in the given study
assemblyfind -t study -id 123 -s

# create a compressed archive containing all assemblies for a study and a CSV file of assembly statistics
assemblyfind -t study -id 123 -archive 
assemblyfind -t study -id 123 -archive study_123_assemblies.tgz

# find all assemblies
assemblyfind -t lane -id 1234_5#6 -stage all

USAGE

# Get databases
my @pathogen_databases = Path::Find->pathogen_databases;

# Set assembly subdirectories
my @sub_directories;
if ($filetype) {
    @sub_directories = (
        '/velvet_assembly', '/velvet_assembly_with_reference',
        '/spades_assembly'
    );
}
else {
    $filetype        = 'contigs';
    @sub_directories = (
        '/velvet_assembly', '/velvet_assembly_with_reference',
        '/spades_assembly'
    );
}

# set file type extension wildcard
my %type_extensions = (
    contigs  => 'unscaffolded_contigs.fa',
    scaffold => 'contigs.fa',
);

my $lane_filter;

for my $database (@pathogen_databases) {

    # Connect to database and get info
    my ( $pathtrack, $dbh, $seq_root ) = Path::Find->get_db_info($database);

    my $find_lanes = Path::Find::Lanes->new(
        search_type    => $type,
        search_id      => $id,
        pathtrack      => $pathtrack,
        dbh            => $dbh,
        processed_flag => 1024
    );
    my @lanes = @{ $find_lanes->lanes };

    unless (@lanes) {
        $dbh->disconnect();
        next;
    }

    # check directories exist, find & filter by file type
    if ( ( defined $symlink || defined $archive ) && !defined $filetype ) {
        $filetype = "contigs";
    }
    $lane_filter = Path::Find::Filter->new(
        lanes           => \@lanes,
        filetype        => $filetype,
        type_extensions => \%type_extensions,
        root            => $root,
        pathtrack       => $pathtrack,
        subdirectories  => \@sub_directories
    );
    my @matching_lanes = $lane_filter->filter;

    # symlink or archive
    # Set up to symlink/archive. Check whether default filetype should be used
    my $use_default = 0;
    $use_default = 1 if ( !defined $filetype );
    if ( $lane_filter->found && ( defined $symlink || defined $archive ) ) {
        my $name;
        if ( defined $symlink ) {
            $name = $symlink;
        }
        elsif ( defined $archive ) {
            $name = $archive;
        }
        $name = "assemblyfind_$id" if ( $name eq '' );

        my %link_names = link_rename_hash( \@matching_lanes );

        my $linker = Path::Find::Linker->new(
            lanes            => \@matching_lanes,
            name             => $name,
            use_default_type => $use_default,
            rename_links     => \%link_names
        );

        $linker->sym_links if ( defined $symlink );
        $linker->archive   if ( defined $archive );
    }

    # print out the paths
    foreach my $ml (@matching_lanes) {
        my $l = $ml->{lane};
        print "$l\n";
    }

    $dbh->disconnect();

    #no need to look in the next database if relevant data has been found
    if ( $lane_filter->found ) {
        exit;
    }
}

unless ( $lane_filter->found ) {

    print "Could not find lanes or files for input data\n";

}

sub link_rename_hash {
    my ($mlanes) = @_;
    my @matching_lanes = @{$mlanes};

    my %suffixes = (
        'velvet_assembly'                => '_velvet.fa',
        'velvet_assembly_with_reference' => '_columbus.fa',
        'spades_assembly'                => '_spades.fa',
        'scaffolding_results'            => '_scaffolded.fa'
    );

    my %link_names;
    foreach my $mf (@matching_lanes) {
        my $lane      = $mf->{lane};
        my @dirs      = split( "/", $lane );
        my $filename  = pop @dirs;
        my $subdir    = pop @dirs;
        my $lane_name = pop @dirs;
        my $suffix    = $suffixes{$subdir};

        $filename =~ s/\.fa/$suffix/;
        my $sf = $link_names{$lane} = "$lane_name.$filename";
    }

    print Dumper \%link_names;
    return %link_names;
}

##### UPDATE #########
#sub generate_stats {
#	# get stats
#    if ( defined($stats) || defined($archive) ) {
#
#        if ( $filetype eq 'auto' || $filetype eq 'all' ) {
#            my $pipeline_path =
#              $pathtrack->hierarchy_path_of_lane( $l, $hierarchy_template );
#            my $pipeline_velvet_row =
#              generate_pipeline_row( "$seq_root/$pipeline_path", $l->name,
#                'velvet_assembly', 'Velvet+Improvement' );
#
#            if ( defined($pipeline_velvet_row) ) {
#                $all_stats .= $pipeline_velvet_row;
#            }
#            my $pipeline_spades_row = generate_pipeline_row(
#                "$seq_root/$pipeline_path", $l->name,
#                'spades_assembly',          'SPAdes'
#            );
#            if ( defined($pipeline_spades_row) ) {
#                $all_stats .= $pipeline_spades_row;
#            }
#        }
#
#        if ( $filetype ne 'auto' ) {
#            my $velvet_row =
#              generate_row( $root, $l->name, 'velvet_assembly', 'Velvet' );
#            my $columbus_row = generate_row( $root, $l->name,
#                'velvet_assembly_with_reference', 'Columbus' );
#            my $final_row =
#              generate_row( $root, $l->name, 'scaffolding_results',
#                'Velvet+Columbus+SSpace' );
#
#            if ( defined($velvet_row) ) {
#                $all_stats .= $velvet_row;
#            }
#            if ( defined($columbus_row) ) {
#                $all_stats .= $columbus_row;
#            }
#            if ( defined($final_row) ) {
#                $all_stats .= $final_row;
#            }
#        }
#    }
#	# create stats file
#    if ( defined($stats) || defined($archive) ) {
#        my $filename_id = $id;
#        $filename_id =~ s/[\W]//gi;
#        $filename_id =
#          $tmpdirectory_name . '/' . $archive_name . '/' . $filename_id
#          if defined($archive);    # save to archive in temp dir
#        open( my $output_stats_fh,
#            '+>' . $filename_id . '_assembly_statistics.csv' )
#          or die "Couldnt create assembly stats file $!\n";
#
#        print {$output_stats_fh} stats_header() . "\n";
#        print {$output_stats_fh} $all_stats;
#        close($output_stats_fh);
#        print "Assembly statistics save to "
#          . $filename_id
#          . '_assembly_statistics.csv' . "\n"
#          if defined($stats);
#
#        # create archive in temp directory and move to output destination
#        archive_lanes( $tmpdirectory_name, $archive_name,
#            $archive_path . $archive_name . $archive_suffix )
#          if defined $archive;
#    }
#
#}

sub generate_pipeline_row {
    my ( $root, $path, $subdirectory, $type ) = @_;
    my $path_to_subdirectory = join( '/', ( $root, $subdirectory ) );
    my $assembly_stats;
    $assembly_stats = basic_assembly_stats_from_file(
        $path_to_subdirectory . '/contigs.fa.stats' );
    return unless ( defined($assembly_stats) );
    my $bamcheck_obj;
    $bamcheck_obj = get_bamcheck_object(
        $path_to_subdirectory . '/contigs.mapped.sorted.bam.bc' );
    return
        $path . "\t"
      . $type . "\t"
      . construct_stats_row( $assembly_stats, $bamcheck_obj ) . "\n";
}

sub generate_row {
    my ( $root, $path, $subdirectory, $type ) = @_;
    my $path_to_subdirectory = join( '/', ( $root, $path, $subdirectory ) );
    my $assembly_stats;
    $assembly_stats = basic_assembly_stats_from_file(
        $path_to_subdirectory . '/contigs.fa.stats' );
    return unless ( defined($assembly_stats) );
    my $bamcheck_obj;
    $bamcheck_obj = get_bamcheck_object(
        $path_to_subdirectory . '/contigs.mapped.sorted.bam.bc' );
    return
        $path . "\t"
      . $type . "\t"
      . construct_stats_row( $assembly_stats, $bamcheck_obj ) . "\n";
}

sub basic_assembly_stats_from_file {
    my ($path_to_file) = @_;
    return if ( !-e $path_to_file );
    my %assembly_stats;

    open( INPUT, $path_to_file ) or die "Couldnt open file $path_to_file\n";
    while (<INPUT>) {
        my $line = $_;
        if ( $line =~
            /sum = ([\d]+), n = ([\d]+), ave = ([\d\.]+), largest = ([\d]+)/ )
        {
            $assembly_stats{total_length}          = $1;
            $assembly_stats{num_contigs}           = $2;
            $assembly_stats{average_contig_length} = $3;
            $assembly_stats{largest_contig}        = $4;
        }
        if ( $line =~ /N50 = ([\d]+), n = ([\d]+)/ ) {
            $assembly_stats{n50}   = $1;
            $assembly_stats{n50_n} = $2;
        }
        if ( $line =~ /N60 = ([\d]+), n = ([\d]+)/ ) {
            $assembly_stats{n60}   = $1;
            $assembly_stats{n60_n} = $2;
        }
        if ( $line =~ /N70 = ([\d]+), n = ([\d]+)/ ) {
            $assembly_stats{n70}   = $1;
            $assembly_stats{n70_n} = $2;
        }
        if ( $line =~ /N80 = ([\d]+), n = ([\d]+)/ ) {
            $assembly_stats{n80}   = $1;
            $assembly_stats{n80_n} = $2;
        }
        if ( $line =~ /N90 = ([\d]+), n = ([\d]+)/ ) {
            $assembly_stats{n90}   = $1;
            $assembly_stats{n90_n} = $2;
        }
        if ( $line =~ /N100 = ([\d]+), n = ([\d]+)/ ) {
            $assembly_stats{n100}   = $1;
            $assembly_stats{n100_n} = $2;
        }
        if ( $line =~ /N_count = ([\d]+)/ ) {
            $assembly_stats{n_count} = $1;
        }
    }
    return \%assembly_stats;
}

sub get_bamcheck_object {
    my ($path_to_file) = @_;
    return if ( !-e $path_to_file || !-s $path_to_file );
    VertRes::Parser::bamcheck->new( file => $path_to_file );
}

sub construct_stats_row {
    my ( $assembly_stats, $bamcheck_object ) = @_;
    my $row = join(
        "\t",
        (
            $assembly_stats->{total_length},
            $assembly_stats->{num_contigs},
            $assembly_stats->{average_contig_length},
            $assembly_stats->{largest_contig},
            $assembly_stats->{n50},
            $assembly_stats->{n50_n},
            $assembly_stats->{n60},
            $assembly_stats->{n60_n},
            $assembly_stats->{n70},
            $assembly_stats->{n70_n},
            $assembly_stats->{n80},
            $assembly_stats->{n80_n},
            $assembly_stats->{n90},
            $assembly_stats->{n90_n},
            $assembly_stats->{n100},
            $assembly_stats->{n100_n},
            $assembly_stats->{n_count}
        )
    );
    if ( defined $bamcheck_object ) {
        $row .= "\t"
          . join(
            "\t",
            (
                $bamcheck_object->get('sequences'),
                $bamcheck_object->get('reads_mapped'),
                $bamcheck_object->get('reads_unmapped'),
                $bamcheck_object->get('reads_paired'),
                $bamcheck_object->get('reads_unpaired'),
                $bamcheck_object->get('total_length'),
                $bamcheck_object->get('bases_mapped'),
                $bamcheck_object->get('bases_mapped_cigar'),
                $bamcheck_object->get('avg_length'),
                $bamcheck_object->get('max_length'),
                $bamcheck_object->get('avg_qual'),
                $bamcheck_object->get('avg_insert_size'),
                $bamcheck_object->get('sd_insert_size')
            )
          );
    }
    else {
        $row .= "\t" . join( "\t", qw(NA NA NA NA NA NA NA NA NA NA NA NA NA) );
    }
    return $row;
}

sub stats_header {
    return join(
        "\t",
        (
            'Lane',
            'Assembly Type',
            'Total Length',
            'No Contigs',
            'Avg Contig Length',
            'Largest Contig',
            'N50',
            'Contigs in N50',
            'N60',
            'Contigs in N60',
            'N70',
            'Contigs in N70',
            'N80',
            'Contigs in N80',
            'N90',
            'Contigs in N90',
            'N100',
            'Contigs in N100',
            'No scaffolded bases (N)',
            'Total Raw Reads',
            'Reads Mapped',
            'Reads Unmapped',
            'Reads Paired',
            'Reads Unpaired',
            'Total Raw Bases',
            'Total Bases Mapped',
            'Total Bases Mapped (Cigar)',
            'Average Read Length',
            'Maximum Read Length',
            'Average Quality',
            'Insert Size Average',
            'Insert Size Std Dev'
        )
    );
}

# Sort routine for multiplexed lane names (eg 1234_5#6)
# Run, Lane and Tag are sorted in ascending order.
# Reverts to alphabetic sort if cannot sort numerically
sub lanesort {
    my @a = split( /\_|\#/, $a->name() );
    my @b = split( /\_|\#/, $b->name() );

    for my $i ( 0 .. 2 ) {
        return ( $a->name cmp $b->name )
          if ( $a[$i] =~ /\D+/ || $b[$i] =~ /\D+/ );
    }

    $a[0] <=> $b[0] || $a[1] <=> $b[1] || $a[2] <=> $b[2];
}
